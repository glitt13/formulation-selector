#' @title Processing script to grab catchment attributes
#' @author Guy Litt \code{guy.litt@noaa.gov}
#' @description
#' Given catchment location data generated by fs_proc and a user-specified
#' configuration file for datasets and corresponding attributes of interest,
#' acquire the attributes for each catchment, write to parquet database.
#' @details Builds a parquet database for each individual comid when calling
#' \code{proc.attr.hydfab::proc_attr_wrap}. From the directory of comids,
#' creates a sub-directory of a specific dataset.
#'
#' NOTE: In defining the featureSource and featureID, it's expected that the
#' term 'gage_id' is used as a variable in glue syntax to create featureID
#' @seealso [fs_proc] A python package that processes input data for the
#' formulation-selector
#' @usage Rscript fs_attrs_grab.R "/path/to/attribute_config.yaml"

# Changelog / Contributions
#   2024-07-24 Originally created, GL

library(tibble)
library(yaml)
library(ncdf4)
library(proc.attr.hydfab)
library(glue)

# TODO is AWS_NO_SIGN_REQUEST necessary??
# Sys.setenv(AWS_NO_SIGN_REQUEST="YES")

# Define command line argument
cmd_args <- commandArgs("trailingOnly" = TRUE)

if(base::length(cmd_args)!=1){
  warning("Unexpected to have more than one argument in Rscript fs_attrs_grab.R /path/to/attribute_config.yaml.")
}

# Read in config file, e.g.  "~/git/formulation-selector/scripts/eval_ingest/SI/SI_attr_config.yaml"
path_attr_config <- cmd_args[1] # "~/git/formulation-selector/scripts/eval_ingest/xssa/xssa_attr_config.yaml"
raw_config <- yaml::read_yaml(path_attr_config)

# A listing of datasets to grab attributes. Dataset names match what is inside dir_std_base.  'all' processes all datasets inside dir_std_base.
datasets <- raw_config$formulation_metadata[[grep("datasets",
        raw_config$formulation_metadata)]]$datasets #c("juliemai-xSSA",'all')[1]

# Define directory paths from the config file
home_dir <- Sys.getenv("HOME")
dir_base <- glue::glue(base::unlist(raw_config$file_io)[['dir_base']])#file.path(home_dir,'noaa','regionalization','data')
dir_std_base <- glue::glue(base::unlist(raw_config$file_io)[['dir_std_base']]) #file.path(dir_base,"input","user_data_std") # The location of standardized data generated by fs_proc python package
dir_db_hydfab <- glue::glue(base::unlist(raw_config$file_io)[['dir_db_hydfab']]) # file.path(dir_base,'input','hydrofabric') # The local dir where hydrofabric data are stored to limit s3 connections
dir_db_attrs <- glue::glue(base::unlist(raw_config$file_io)[['dir_db_attrs']])  # file.path(dir_base,'input','attributes') # The parent dir where each comid's attribute parquet file is stored in the subdirectory 'comid/', and each dataset's aggregated parquet attributes are stored in the subdirectory '/{dataset_name}

# Read s3 connection details
s3_base <- base::unlist(raw_config$hydfab_config)[['s3_base']]#s3://lynker-spatial/tabular-resources" # s3 path containing hydrofabric-formatted attribute datasets
s3_bucket <- base::unlist(raw_config$hydfab_config)[['s3_bucket']] #'lynker-spatial' # s3 bucket containing hydrofabric data

# s3 path to hydroatlas data formatted for hydrofabric
if ("s3_path_hydatl" %in% names(base::unlist(raw_config$attr_select))){
  s3_path_hydatl <- glue::glue(base::unlist(raw_config$attr_select)[['s3_path_hydatl']])  # glue::glue('{s3_base}/hydroATLAS/hydroatlas_vars.parquet')
} else {
  s3_path_hydatl <- NULL
}

# Additional config options
hf_cat_sel <-  base::unlist(raw_config$hydfab_config)[['hf_cat_sel']] #c("total","all")[1] # total: interested in the single location's aggregated catchment data; all: all subcatchments of interest
ext <- base::unlist(raw_config$hydfab_config)[['ext']] # 'gpkg'

#-----------------------------------------------------
# Variable listings:
names_attr_sel <- base::unlist(base::lapply(raw_config$attr_select,
                                            function(x) base::names(x)))

# Transform into single named list of lists rather than nested sublists
idxs_vars <- base::grep("_vars", names_attr_sel)
var_names <- names_attr_sel[idxs_vars]
sub_attr_sel <- base::lapply(idxs_vars, function(i)
  raw_config$attr_select[[i]][[1]])
base::names(sub_attr_sel) <- var_names

# Subset to only those non-null variables:
sub_attr_sel <- sub_attr_sel[base::unlist(base::lapply(sub_attr_sel,
                          function(x) base::any(!base::is.null(unlist(x)))))]
var_names_sub <- names(sub_attr_sel)
#-----------------------------------------------------
message(glue::glue("Attribute dataset sources include the following:\n
  {paste0(var_names_sub,collapse='\n')}"))

message(glue::glue("Attribute variables to be acquired include :\n
  {paste0(sub_attr_sel,collapse='\n')}"))

Retr_Params <- base::list(paths = base::list(
  # Note that if a path is provided, ensure the
  # name includes 'path'. Same for directory having variable name with 'dir'
                        dir_db_hydfab=dir_db_hydfab,
                        dir_db_attrs=dir_db_attrs,
                        s3_path_hydatl = s3_path_hydatl,
                        dir_std_base = dir_std_base),
                   vars = sub_attr_sel,
                   datasets = datasets
       )
# PROCESS ATTRIBUTES
ls_comids <- proc.attr.hydfab:::grab_attrs_datasets_fs_wrap(Retr_Params,overwrite = TRUE)

# --------------------------- Compile attributes --------------------------- #
# Demonstration of how to retrieve attributes/comids that exist inside dir_db_attrs:
# The comids of interest
comids <- ls_comids %>% base::unname() %>% base::unlist()

# The attribute variables of interest
vars <- Retr_Params$vars %>% base::unlist() %>% base::unname()

dat_all_attrs <- proc.attr.hydfab::retrieve_attr_exst(comids, vars,
                                                      Retr_Params$paths$dir_db_attrs)
base::rm(dat_all_attrs)
